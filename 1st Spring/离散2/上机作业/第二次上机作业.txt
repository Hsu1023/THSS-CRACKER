实现 Dijkstra 算法，求非负权有向图的最短路径 。
采用正向表进行图（不含有重边或自环，但可能有环路）的存储，下面进行具体的介绍：
第 1 行包含空格隔开的顶点个数 v（1 <= v < 100）和边的个数 e（1 <= e < 200）。
第 2 行包含 v+1 个整数（空格隔开）p(i)（0 <= i <= v, 0 <= p(i) <= e）。
第 3 行包含 e 个整数（空格隔开）q(i)（0 <= i <= e-1, 0 <= q(i) <= v-1）。
第 4 行包含 e 个整数（空格隔开，代表权重） r(i)。
第 5 行包含测试点对的个数 n（1 <= n <= 100）。
第 6~5+n 行包含空格隔开的起始顶点 Vs(i) 和终止顶点 Ve(i)（0 <= Vs, Ve <= v-1）。
边权，边权和均不会超过int的范围。
【输出格式】
输出文件包含n行，每行为相应测试点对的其中一条最短路径和路径长度，如：
[Vs(i)->...->Ve(i) W]
若结点间不这样的路径，则输出 NO PATH。
每行结尾都需要换行符

例如输入：
6 10
0 2 4 7 7 9 10
1 2 3 5 1 4 5 1 3 4
7 1 4 1 6 2 7 3 5 3
12
0 1
0 2
0 3
0 4
0 5
1 2
1 3
1 4
2 5
3 4
3 5
4 5
____________________________
输出：
[0->2->4->1 6]
[0->2 1]
[0->2->4->3 8]
[0->2->4 3]
[0->2->4->1->5 7]
NO PATH
[1->3 4]
[1->5->4 4]
[2->4->1->5 6]
NO PATH
NO PATH
[4->1->5 4]
____________________________
若有多条最短路径，只需找到一条。
若算法实现正确，程序在一般的电脑上均应在2秒内出结果。
不限制编程语言，但尽量使用C/C++，直接在控制台输入输出，允许使用C++的 STL等工具，可写在一个文件里，最终只需提交.cpp文件，请将重命名为：学号 _姓名 .cpp即可（网络学堂批量下载学生作业后也是这么命名的）。请保证你的代码至少可以在https://glot.io/平台上运行。